"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeMessagesArgs = exports.mergeMessagesFiles = exports.mergeMessages = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const type_guards_1 = require("./type-guards");
const messages_1 = require("./messages");
const assertions_1 = require("./assertions");
const error_1 = require("./error");
function identity(value) {
    return value;
}
function sortByTimestamp(a, b) {
    return ((0, messages_1.durationToNanoseconds)(a.timestamp) - (0, messages_1.durationToNanoseconds)(b.timestamp));
}
function mergeMessages(messagesCols) {
    const messages = messagesCols.flat();
    const sourcesSeen = new Set();
    const sources = messages.map((message) => message.source).filter(type_guards_1.notNull);
    for (const { uri } of sources) {
        if (sourcesSeen.has(uri)) {
            throw new error_1.CypressCucumberError(`Found duplicate sources in collections: ${uri} (this usually means you're trying to merge unrelated reports)"`);
        }
        else {
            sourcesSeen.add(uri);
        }
    }
    const meta = (0, assertions_1.assertAndReturn)(messages.map((message) => message.meta).find(type_guards_1.notNull), "Expected to find a meta envelope");
    const testRunStarted = (0, assertions_1.assertAndReturn)(messages
        .map((message) => message.testRunStarted)
        .filter(type_guards_1.notNull)
        .sort(sortByTimestamp)
        .find(identity), "Expected to find a testRunStarted envelope");
    const testRunFinished = (0, assertions_1.assertAndReturn)(messages
        .map((message) => message.testRunFinished)
        .filter(type_guards_1.notNull)
        .sort(sortByTimestamp)
        .findLast(identity), "Expected to find a testRunFinished envelope");
    const isPassThroughMessage = (message) => message.meta == null &&
        message.testRunStarted == null &&
        message.testRunFinished == null;
    return [
        { meta },
        { testRunStarted },
        ...messages.filter(isPassThroughMessage),
        { testRunFinished },
    ];
}
exports.mergeMessages = mergeMessages;
async function mergeMessagesFiles(files) {
    const contents = await Promise.all(files.map((file) => promises_1.default.readFile(file)));
    const messages = mergeMessages(contents.map((content) => content
        .toString()
        .trim()
        .split("\n")
        .map((line) => JSON.parse(line))));
    return messages.map((message) => JSON.stringify(message)).join("\n");
}
exports.mergeMessagesFiles = mergeMessagesFiles;
async function mergeMessagesArgs(options) {
    const [, , ...files] = options.argv;
    options.stdout.write(await mergeMessagesFiles(files));
}
exports.mergeMessagesArgs = mergeMessagesArgs;
